<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>RCS 대화형 AI</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@400;500;700&display=swap" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <style>
        body {
            font-family: 'Noto Sans KR', sans-serif;
        }
        #chat-window {
            scroll-behavior: smooth;
        }
        .chat-bubble {
            max-width: 80%;
            animation: fadeIn 0.3s ease-out;
        }
        .chat-bubble.user {
            background-color: #3b82f6; /* blue-600 */
            color: white;
        }
        .chat-bubble.ai {
            background-color: #e2e8f0; /* slate-200 */
            color: #1e293b; /* slate-800 */
        }
        .chat-bubble.ai p, .chat-bubble.ai ul, .chat-bubble.ai ol {
            margin-bottom: 0.5rem;
        }
         .chat-bubble.ai li {
            margin-left: 1.5rem;
        }
        .chat-bubble.ai h3 {
            font-weight: bold;
            font-size: 1.1rem;
            margin-bottom: 0.5rem;
        }
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        @keyframes typing {
            0% { content: '.'; }
            33% { content: '..'; }
            66% { content: '...'; }
        }
        .typing-indicator::after {
            content: '.';
            animation: typing 1s infinite;
        }
    </style>
</head>
<body class="bg-slate-100 flex flex-col h-screen">

    <!-- 헤더 -->
    <header class="bg-white shadow-md w-full p-4 text-center z-10">
        <h1 class="text-2xl font-bold text-slate-800">
            <i class="fa-solid fa-brain text-blue-500"></i> RCS 대화형 AI
        </h1>
        <p class="text-sm text-slate-500">당신의 생각 파트너, RCS에게 무엇이든 물어보세요.</p>
    </header>

    <!-- 채팅 창 -->
    <main class="flex-grow overflow-y-auto p-4" id="chat-window">
        <div class="flex flex-col space-y-4" id="message-list">
            <!-- 메시지가 여기에 추가됩니다. -->
        </div>
    </main>

    <!-- 입력 폼 -->
    <footer class="bg-white p-4 border-t">
        <form id="chat-form" class="flex items-center gap-4 max-w-4xl mx-auto">
            <input type="text" id="message-input" placeholder="RCS에게 메시지 보내기..." class="flex-grow p-3 border-2 border-slate-200 rounded-full focus:ring-2 focus:ring-blue-500 focus:border-blue-500 outline-none transition" autocomplete="off">
            <button type="submit" id="send-btn" class="bg-blue-600 hover:bg-blue-700 text-white font-bold w-12 h-12 rounded-full transition-transform transform hover:scale-110 flex items-center justify-center">
                <i class="fa-solid fa-paper-plane"></i>
            </button>
        </form>
    </footer>

    <script>
        const chatForm = document.getElementById('chat-form');
        const messageInput = document.getElementById('message-input');
        const sendBtn = document.getElementById('send-btn');
        const messageList = document.getElementById('message-list');
        const chatWindow = document.getElementById('chat-window');

        let chatHistory = [];

        // 지수 백오프를 위한 변수
        const maxRetries = 3; // 최대 재시도 횟수
        const initialDelay = 1000; // 초기 대기 시간 (1초)

        // 페이지 로드 시 첫 메시지 표시
        window.addEventListener('load', () => {
            const initialPrompt = "당신은 사용자의 생각 파트너인 'RCS(Responsive Creative Solver)'입니다. 사용자가 아이디어를 발전시키고 문제를 해결하도록 창의적이고 친절하게 대화를 이끌어주세요. 먼저 사용자에게 어떤 주제에 대해 이야기하고 싶은지 물어보며 대화를 시작하세요.";
            chatHistory.push({ role: "user", parts: [{ text: initialPrompt }] });
            sendMessageToAI(true); // 첫 메시지는 사용자에게 보이지 않음
        });

        // 폼 제출 이벤트 (메시지 전송)
        chatForm.addEventListener('submit', (e) => {
            e.preventDefault();
            const userMessage = messageInput.value.trim();
            if (!userMessage) return;

            addMessage(userMessage, 'user');
            chatHistory.push({ role: "user", parts: [{ text: userMessage }] });
            messageInput.value = '';

            sendMessageToAI(false);
        });

        // AI에게 메시지 전송 및 응답 처리
        async function sendMessageToAI(isInitial = false) {
            addTypingIndicator();
            sendBtn.disabled = true;
            sendBtn.classList.add('opacity-50');

            for (let retry = 0; retry <= maxRetries; retry++) {
                try {
                    // 여기에 발급받은 API 키를 넣어주세요.
                    // 예: const apiKey = "AIzaSyDxxFwUv8wbdstvnRoO8VnpZSSEvZaHsTw";
                    const apiKey = "AIzaSyDxxFwUv8wbdstvnRoO8VnpZSSEvZaHsTw"; 
                    const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-05-20:generateContent?key=${apiKey}`;
                    
                    const payload = { contents: chatHistory };

                    const response = await fetch(apiUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload)
                    });

                    // API 응답이 성공적이면 루프를 종료합니다.
                    if (response.ok) {
                        const result = await response.json();
                        removeTypingIndicator();

                        if (result.candidates && result.candidates.length > 0) {
                            const aiMessage = result.candidates[0].content.parts[0].text;
                            chatHistory.push({ role: "model", parts: [{ text: aiMessage }] });
                            if (!isInitial) {
                                addMessage(aiMessage, 'ai');
                            } else {
                                addMessage(aiMessage, 'ai');
                            }
                        } else {
                            addMessage("죄송해요, 응답을 생성하는 데 문제가 발생했어요. 다시 시도해 주시겠어요?", 'ai');
                        }
                        break; // 성공 시 루프 종료
                    } else {
                        // 5xx 서버 오류는 재시도합니다.
                        if (response.status >= 500 && response.status < 600 && retry < maxRetries) {
                            const delay = initialDelay * Math.pow(2, retry);
                            console.log(`API 요청 실패, ${delay}ms 후 재시도...`);
                            await new Promise(resolve => setTimeout(resolve, delay));
                        } else {
                            // 다른 오류는 재시도하지 않고 오류 메시지 표시
                            removeTypingIndicator();
                            throw new Error(`API Error: ${response.statusText}`);
                        }
                    }
                } catch (error) {
                    console.error('Error:', error);
                    removeTypingIndicator();
                    addMessage("오류가 발생했습니다. 네트워크 연결을 확인하고 다시 시도해주세요.", 'ai');
                    break; // 오류 발생 시 루프 종료
                }
            }
            // `finally` 블록의 내용이 이곳으로 옮겨져 구문 오류를 해결합니다.
            // 모든 재시도 시도 후에 버튼이 활성화됩니다.
            sendBtn.disabled = false;
            sendBtn.classList.remove('opacity-50');
            messageInput.focus();
        }

        // 채팅창에 메시지 추가
        function addMessage(text, sender) {
            const bubble = document.createElement('div');
            bubble.className = `chat-bubble p-4 rounded-2xl w-fit ${sender === 'user' ? 'user self-end' : 'ai self-start'}`;
            
            if (sender === 'ai') {
                bubble.innerHTML = marked.parse(text); // Markdown을 HTML로 변환
            } else {
                bubble.textContent = text;
            }
            
            messageList.appendChild(bubble);
            chatWindow.scrollTop = chatWindow.scrollHeight; // 항상 최신 메시지로 스크롤
        }

        // AI 타이핑 인디케이터 추가/제거
        function addTypingIndicator() {
            const typingBubble = document.createElement('div');
            typingBubble.id = 'typing-indicator';
            typingBubble.className = 'chat-bubble ai self-start p-4 rounded-2xl';
            typingBubble.innerHTML = `<div class="typing-indicator text-slate-500"></div>`;
            messageList.appendChild(typingBubble);
            chatWindow.scrollTop = chatWindow.scrollHeight;
        }

        function removeTypingIndicator() {
            const indicator = document.getElementById('typing-indicator');
            if (indicator) {
                indicator.remove();
            }
        }
    </script>
</body>
</html>
